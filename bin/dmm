#!/usr/bin/env python

import os
import re
import sys
import argparse
import logging
import time
import shutil
import pathlib
from datetime import datetime
import json 
import numpy as np

import dmm2bm

from dmm2bm import config
from dmm2bm import __version__
from dmm2bm import log
from dmm2bm import util

from importlib.resources import files

data_path = pathlib.Path(__file__).parent
# data_path = files('data')

def init(args):

    if not os.path.exists(str(args.config)):
        config.write(args.config)
    else:
        log.error("{0} already exists".format(args.config))

def run_status(args):
    config.log_values(args)

def run_mono(args):
    config.log_values(args)

    energy_select = np.around(args.energy, decimals=2) 

    print(data_path.joinpath('dmm.json'))
    print(os.path.join(sys.prefix))
    print(files('dmm2bm.data').joinpath('dmm.json').read_text())
    return
    with open(data_path.joinpath('dmm.json')) as json_file:
        energy_lookup = json.load(json_file)
    # print(energy_lookup['Mono'])

    energy_list = []

    for key in energy_lookup['Mono']:
        energy_list.append(key)

    log.info('Selected energy: %4.2f keV'  %  energy_select)
    log.info('Pre-calibrated energies: %s' %  energy_list)

    energies_str = np.array(energy_list)
    energies_flt = [float(i) for i in  energies_str]
    energy_max = np.max(energies_flt)
    energy_min = np.min(energies_flt)

    if energy_select < energy_max and energy_select >= energy_min:
        energy_calibrated = util.find_nearest(energies_flt, energy_select)
        
        log.info('   ***   Selected energy %s; Nearest calibrated: %s ' % (energy_select, energy_calibrated))
        print(energies_str)
        print(str(energy_calibrated))
        return
        energy_closer_index  = np.where(energies_str == str(energy_calibrated))[0][0]

        if energy_select >= float(energy_calibrated):
            energy_low  = np.around(float(energies_str[energy_closer_index]), decimals=2)
            energy_high = np.around(float(energies_str[energy_closer_index+1]), decimals=2)
        else:
            energy_low  = np.around(float(energies_str[energy_closer_index-1]), decimals=2)
            energy_high = np.around(float(energies_str[energy_closer_index]), decimals=2)
           
        log.info("   ***   Calibrated range [%4.2f, %4.2f]" % (energy_low, energy_high))
        n = int(100*(energy_high-energy_low))
        interp_energies = np.linspace(energy_low, energy_high, n).round(decimals=2)

    else:
        log.error('Error: energy selected %4.2f is outside the calibrated range [%4.2f, %4.2f]' %(energy_select, energy_min, energy_max))

    # if (config.CONFIG_FILE_NAME == args.config):
    #     config.set_default_config(args)            
    # if(epics.move(args)):    
    # config.save_params_to_config(args)

def run_pink(args):
    config.log_values(args)
    # if (config.CONFIG_FILE_NAME == args.config):
    #     config.set_default_config(args)            
    # if(epics.move(args)):    
    config.save_params_to_config(args)


def run_save(args):
    return
    # config.save_current_positions_to_config(args)
    
def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--config', **config.SECTIONS['general']['config'])
    parser.add_argument('--version', action='version',
                        version='%(prog)s {}'.format(__version__))

    mono_params = config.MONO_PARAMS    
    pink_params = config.PINK_PARAMS    
    
    cmd_parsers = [
        ('init',        init,           (),               "Create configuration file"),
        ('mono',         run_mono,        mono_params,  "Set DMM energy"),
        ('pink',         run_pink,        pink_params,  "Set the beamline to pink mode"),
        ('save',        run_save,       mono_params,  "Associate the current beamline positions to an energy value"),             
        ('status',      run_status,     mono_params,  "Show status"),
    ]

    subparsers = parser.add_subparsers(title="Commands", metavar='')

    for cmd, func, sections, text in cmd_parsers:
        cmd_params = config.Params(sections=sections)
        cmd_parser = subparsers.add_parser(cmd, help=text, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        cmd_parser = cmd_params.add_arguments(cmd_parser)
        cmd_parser.set_defaults(_func=func)

    args = config.parse_known_args(parser, subparser=True)

    # create logger
    logs_home = args.logs_home

    # make sure logs directory exists
    if not os.path.exists(logs_home):
        os.makedirs(logs_home)

    lfname = os.path.join(logs_home, 'dmm_' + datetime.strftime(datetime.now(), "%Y-%m-%d_%H_%M_%S") + '.log')
 
    log.setup_custom_logger(lfname)
    log.info("Saving log at %s" % lfname)

    try:
        args._func(args)
    except RuntimeError as e:
        log.error(str(e))
        sys.exit(1)

if __name__ == '__main__':
    main()
